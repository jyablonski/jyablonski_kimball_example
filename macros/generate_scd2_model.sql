{#
    Macro to generate SCD2 (Slowly Changing Dimension Type 2) tables
    
    Parameters:
    - source_relation: The source table (use source() or ref())
    - primary_key: The unique identifier for each audit/version record (e.g., 'id', 'audit_id')
    - entity_id: The business key that groups records (e.g., 'customer_id', 'store_id')
    - timestamp_field: The field tracking when the record was created/modified (e.g., 'modified_at', 'created_at')
    - additional_columns: List of additional columns to include (default: all columns from source)
    - deleted_flag_column: Optional column indicating deletion (e.g., 'is_deleted', 'audit_type')
    - deleted_flag_value: The value indicating a deletion (e.g., true, 2, 'deleted')
    - unique_key: Override for dbt config unique_key (defaults to primary_key)
    - indexes: List of column names to index (defaults to [entity_id])
    
    Example usage in a model:
    
    {{ generate_scd2_model(
        source_relation=source('app_db', 'customer_audit'),
        primary_key='id',
        entity_id='customer_id',
        timestamp_field='modified_at',
        additional_columns=['customer_name', 'email', 'address', 'city', 'state'],
        deleted_flag_column='audit_type',
        deleted_flag_value=2
    ) }}
#}

{% macro generate_scd2_model(
    source_relation,
    primary_key,
    entity_id,
    timestamp_field,
    additional_columns=none,
    deleted_flag_column=none,
    deleted_flag_value=none,
    unique_key=none,
    indexes=none
) %}

{{ config(
    materialized='incremental',
    unique_key=unique_key if unique_key else primary_key,
    incremental_strategy='merge',
    indexes=indexes if indexes else [{'columns': [entity_id]}]
) }}

/*
SCD2 table for {{ source_relation }}
Tracks historical changes with validity periods for {{ entity_id }}
Generated by generate_scd2_model macro
*/

with new_records as (
    select
        {{ primary_key }},
        {{ entity_id }},
        {{ timestamp_field }}
        {% if deleted_flag_column %}
        , {{ deleted_flag_column }}
        {% endif %}
    from {{ source_relation }}
    where {{ timestamp_field }} is not null
    {% if is_incremental() %}
        and {{ timestamp_field }} > (select max(valid_from) from {{ this }})
    {% endif %}
),

{% if is_incremental() %}
    -- Get previous current records for entities that have new changes
    previous_records as (
        select
            {{ primary_key }},
            {{ entity_id }},
            valid_from as {{ timestamp_field }}
            {% if deleted_flag_column %}
            , cast(null as integer) as {{ deleted_flag_column }}
            {% endif %}
        from {{ this }}
        where
            {{ entity_id }} in (select {{ entity_id }} from new_records)
            and is_current_record = 1
    ),
    
    -- Combine previous and new records
    combined_records as (
        select * from previous_records
        union all
        select * from new_records
    ),
{% endif %}

-- Calculate validity periods using window functions
validity_periods as (
    select
        {{ primary_key }},
        {{ entity_id }},
        {{ timestamp_field }} as valid_from,
        {% if deleted_flag_column %}
        -- If record is deleted, set valid_to = valid_from (point-in-time deletion)
        case
            when {{ deleted_flag_column }} = {{ deleted_flag_value }} then {{ timestamp_field }}
            else coalesce(
                lead({{ timestamp_field }}) over (
                    partition by {{ entity_id }}
                    order by {{ timestamp_field }}
                ),
                '9999-12-31'::timestamp
            )
        end as valid_to,
        {{ deleted_flag_column }},
        {% else %}
        coalesce(
            lead({{ timestamp_field }}) over (
                partition by {{ entity_id }}
                order by {{ timestamp_field }}
            ),
            '9999-12-31'::timestamp
        ) as valid_to,
        {% endif %}
        row_number() over (
            partition by {{ entity_id }}
            order by {{ timestamp_field }} desc
        ) as rn_desc
    from {% if is_incremental() %}combined_records{% else %}new_records{% endif %}
),

-- Join back to source to get all columns
final as (
    select
        vp.{{ primary_key }},
        vp.{{ entity_id }},
        {% if additional_columns %}
            {% for col in additional_columns %}
        src.{{ col }},
            {% endfor %}
        {% else %}
        src.*,
        {% endif %}
        vp.valid_from,
        vp.valid_to,
        {% if deleted_flag_column %}
        case
            when vp.{{ deleted_flag_column }} = {{ deleted_flag_value }} then 1
            else 0
        end as is_deleted,
        {% endif %}
        case
            when vp.valid_to = '9999-12-31'::timestamp 
            {% if deleted_flag_column %}
                and vp.{{ deleted_flag_column }} != {{ deleted_flag_value }}
            {% endif %}
            then 1
            else 0
        end as is_current_record,
        case
            when vp.rn_desc = 1 then 1
            else 0
        end as is_latest_record,
        current_timestamp as dbt_updated_at
    from validity_periods vp
    inner join {{ source_relation }} src
        on vp.{{ primary_key }} = src.{{ primary_key }}
)

select * from final

{% endmacro %}